From ab40c027f0ce9492919a72ad339de40bdb84b354 Mon Sep 17 00:00:00 2001
From: Dimitry Andric <dimitry@andric.com>
Date: Mon, 3 May 2021 20:08:49 +0200
Subject: [PATCH] [MC][ELF] Work around R_MIPS_LO16 relocation handling problem

This fixes PR49821, and avoids "ld.lld: error: test.o:(.rodata.str1.1):
offset is outside the section" errors when linking MIPS objects with
negative R_MIPS_LO16 implicit addends.

ld.lld handles R_MIPS_HI16/R_MIPS_LO16 separately, not as a whole, so it
doesn't know that an R_MIPS_HI16 with implicit addend 1 and an
R_MIPS_LO16 with implicit addend -32768 represents 32768, which is in
range of a MergeInputSection. We could introduce a new RelExpr member
(like R_RISCV_PC_INDIRECT for R_RISCV_PCREL_HI20 / R_RISCV_PCREL_LO12)
but the complexity is unnecessary given that GNU as keeps the original
symbol for this case as well.

Reviewed By: atanasyan, MaskRay

Differential Revision: https://reviews.llvm.org/D101773
---
 llvm/lib/MC/ELFObjectWriter.cpp | 11 +++++++++++
 llvm/test/MC/Mips/mips_lo16.s   | 22 ++++++++++++++++++++++
 2 files changed, 33 insertions(+)
 create mode 100644 llvm/test/MC/Mips/mips_lo16.s

Index: llvm-toolchain-12_12.0.1~+rc1/llvm/lib/MC/ELFObjectWriter.cpp
===================================================================
--- llvm-toolchain-12_12.0.1~+rc1.orig/llvm/lib/MC/ELFObjectWriter.cpp
+++ llvm-toolchain-12_12.0.1~+rc1/llvm/lib/MC/ELFObjectWriter.cpp
@@ -1397,6 +1397,17 @@ bool ELFObjectWriter::shouldRelocateWith
       if (TargetObjectWriter->getEMachine() == ELF::EM_386 &&
           Type == ELF::R_386_GOTOFF)
         return true;
+
+      // ld.lld handles R_MIPS_HI16/R_MIPS_LO16 separately, not as a whole, so
+      // it doesn't know that an R_MIPS_HI16 with implicit addend 1 and an
+      // R_MIPS_LO16 with implicit addend -32768 represents 32768, which is in
+      // range of a MergeInputSection. We could introduce a new RelExpr member
+      // (like R_RISCV_PC_INDIRECT for R_RISCV_PCREL_HI20 / R_RISCV_PCREL_LO12)
+      // but the complexity is unnecessary given that GNU as keeps the original
+      // symbol for this case as well.
+      if (TargetObjectWriter->getEMachine() == ELF::EM_MIPS &&
+          !hasRelocationAddend())
+        return true;
     }
 
     // Most TLS relocations use a got, so they need the symbol. Even those that
Index: llvm-toolchain-12_12.0.1~+rc1/llvm/test/MC/Mips/mips_lo16.s
===================================================================
--- /dev/null
+++ llvm-toolchain-12_12.0.1~+rc1/llvm/test/MC/Mips/mips_lo16.s
@@ -0,0 +1,22 @@
+# PR49821: Check that R_MIPS_LO16 relocs do not wrap around with large addends.
+
+# RUN: llvm-mc %s -triple mips-unknown-unknown -filetype=obj | \
+# RUN:	 llvm-objdump -d -r --no-show-raw-insn - | \
+# RUN:   FileCheck -check-prefix=MIPS32 %s
+
+# RUN: llvm-mc %s -triple mips64-unknown-unknown -filetype=obj | \
+# RUN:	 llvm-objdump -d -r --no-show-raw-insn - | \
+# RUN:   FileCheck -check-prefix=MIPS64 %s
+
+	.text
+foo:
+	lui	$2, %hi(bar)
+# MIPS32: 00000000:  R_MIPS_HI16  bar
+# MIPS64: 0000000000000000:  R_MIPS_HI16/R_MIPS_NONE/R_MIPS_NONE	.rodata.str1.1+0x8000
+	addiu	$2, $2, %lo(bar)
+# MIPS32: 00000004:  R_MIPS_LO16  bar
+# MIPS64: 0000000000000004:  R_MIPS_LO16/R_MIPS_NONE/R_MIPS_NONE	.rodata.str1.1+0x8000
+	.section	.rodata.str1.1,"aMS",@progbits,1
+	.zero 0x8000
+bar:
+	.asciz	"hello"
