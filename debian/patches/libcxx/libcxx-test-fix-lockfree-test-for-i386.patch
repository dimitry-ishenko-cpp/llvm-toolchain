Lock is_always_lock free test fails on i386 because std::atomic is aligned
to 8 bytes while long long is aligned to 4 bytes. clang can't generate inline
code for unaligned 8 byte atomics even tough instruction set and gcc support
it.

That makes it expected thaqt ATOMIC_LLONG_LOCK_FREE and
std::atomic<long long>::is_always_lock_free don't match on i386. Correct test
for std::atomic<long long> is to check if target cpu support cmpxchg8 instruction.
To set instruction support one can check __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 define.

Bug: https://llvm.org/bugs/show_bug.cgi?id=19355

Index: llvm-toolchain-19_19.1.2~++20241011093632+6c1fd539e43e/libcxx/test/std/atomics/atomics.lockfree/is_always_lock_free.pass.cpp
===================================================================
--- llvm-toolchain-19_19.1.2~++20241011093632+6c1fd539e43e.orig/libcxx/test/std/atomics/atomics.lockfree/is_always_lock_free.pass.cpp
+++ llvm-toolchain-19_19.1.2~++20241011093632+6c1fd539e43e/libcxx/test/std/atomics/atomics.lockfree/is_always_lock_free.pass.cpp
@@ -27,6 +27,14 @@
 #include "test_macros.h"
 #include "atomic_helpers.h"
 
+#if defined(__i386__) && defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8)
+/* Fix for clang setting __GCC_ATOMIC_LLONG_LOCK_FREE incorrectly for x86
+ * https://llvm.org/bugs/show_bug.cgi?id=19355
+ */
+#undef ATOMIC_LLONG_LOCK_FREE
+#define ATOMIC_LLONG_LOCK_FREE 2
+#endif
+
 template <typename T>
 void check_always_lock_free(std::atomic<T> const& a) {
   using InfoT = LockFreeStatusInfo<T>;
