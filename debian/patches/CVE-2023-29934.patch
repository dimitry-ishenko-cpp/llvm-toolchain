From 80d5400d924e543c5420f4e924f5818313605e99 Mon Sep 17 00:00:00 2001
From: Jakub Kuderski <kubak@google.com>
Date: Mon, 9 Jan 2023 11:35:46 -0500
Subject: [PATCH] [mlir][spirv] Account for type conversion failures in
 scf-to-spirv

Fixes: https://github.com/llvm/llvm-project/issues/59136

Reviewed By: antiagainst

Differential Revision: https://reviews.llvm.org/D141292
---
 mlir/lib/Conversion/SCFToSPIRV/SCFToSPIRV.cpp |  5 +++++
 mlir/test/Conversion/SCFToSPIRV/if.mlir       | 14 ++++++++++++++
 2 files changed, 19 insertions(+)

--- llvm-toolchain-15-15.0.7.orig/mlir/lib/Conversion/SCFToSPIRV/SCFToSPIRV.cpp
+++ llvm-toolchain-15-15.0.7/mlir/lib/Conversion/SCFToSPIRV/SCFToSPIRV.cpp
@@ -17,6 +17,7 @@
 #include "mlir/Dialect/SPIRV/Transforms/SPIRVConversion.h"
 #include "mlir/IR/BuiltinOps.h"
 #include "mlir/Transforms/DialectConversion.h"
+#include "llvm/Support/FormatVariadic.h"
 
 using namespace mlir;
 
@@ -286,6 +287,10 @@ IfOpConversion::matchAndRewrite(scf::IfO
   SmallVector<Type, 8> returnTypes;
   for (auto result : ifOp.getResults()) {
     auto convertedType = typeConverter.convertType(result.getType());
+    if (!convertedType)
+      return rewriter.notifyMatchFailure(
+          loc, llvm::formatv("failed to convert type '{0}'", result.getType()));
+
     returnTypes.push_back(convertedType);
   }
   replaceSCFOutputValue(ifOp, selectionOp, rewriter, scfToSPIRVContext,
--- llvm-toolchain-15-15.0.7.orig/mlir/test/Conversion/SCFToSPIRV/if.mlir
+++ llvm-toolchain-15-15.0.7/mlir/test/Conversion/SCFToSPIRV/if.mlir
@@ -153,4 +153,18 @@ func.func @simple_if_yield_type_change(%
   return
 }
 
+// Memrefs without a spirv storage class are not supported. The conversion
+// should preserve the `scf.if` and not crash.
+func.func @unsupported_yield_type(%arg0 : memref<8xi32>, %arg1 : memref<8xi32>, %c : i1) {
+// CHECK-LABEL: @unsupported_yield_type
+// CHECK-NEXT:    scf.if
+// CHECK:         spirv.Return
+  %r = scf.if %c -> (memref<8xi32>) {
+    scf.yield %arg0 : memref<8xi32>
+  } else {
+    scf.yield %arg1 : memref<8xi32>
+  }
+  return
+}
+
 } // end module
